/**
 * F1 Data Scraper
 * 
 * Orchestratore principale per il recupero dati F1
 */

import { OpenF1Service } from './service.js';
import type {
  ScraperConfig,
  GrandPrixData,
  ScraperResult,
  SessionData,
  Meeting,
  Session,
} from './types.js';

export class F1Scraper {
  private readonly service: OpenF1Service;

  constructor() {
    this.service = new OpenF1Service();
  }

  /**
   * Recupera i dati dell'ultimo Gran Premio
   */
  async scrapeLatestGrandPrix(
    config: Omit<ScraperConfig, 'year' | 'meetingKey'> = {}
  ): Promise<ScraperResult<GrandPrixData>> {
    try {
      console.log('\nüèéÔ∏è  F1 DATA SCRAPER - Ultimo Gran Premio\n');
      console.log('‚îÅ'.repeat(50));

      // 1. Ottieni ultimo meeting
      const meetingResult = await this.service.getLatestMeeting();
      if (!meetingResult.success || !meetingResult.data) {
        return {
          success: false,
          error: meetingResult.error ?? { code: 'NO_DATA', message: 'Nessun meeting disponibile' },
          timestamp: new Date().toISOString(),
        };
      }

      const meeting = meetingResult.data;
      console.log(`\nüìç ${meeting.meeting_name}`);
      console.log(`   ${meeting.location}, ${meeting.country_name}`);
      console.log(`   ${new Date(meeting.date_start).toLocaleDateString('it-IT')}`);

      // 2. Ottieni tutte le sessioni
      const sessionsResult = await this.service.getSessions(meeting.meeting_key);
      if (!sessionsResult.success || !sessionsResult.data) {
        return {
          success: false,
          error: sessionsResult.error ?? { code: 'NO_DATA', message: 'Nessuna sessione disponibile' },
          timestamp: new Date().toISOString(),
        };
      }

      const sessions = sessionsResult.data;
      
      // 3. Filtra sessioni se richiesto
      const sessionsToScrape = config.sessionTypes
        ? sessions.filter(s => config.sessionTypes!.includes(s.session_name as any))
        : sessions;

      console.log(`\nüîç Sessioni da elaborare: ${sessionsToScrape.length}`);

      // 4. Recupera dati per ogni sessione
      const sessionsData = await this.scrapeSessionsData(sessionsToScrape, config);

      // 5. Costruisci risultato finale
      const grandPrixData: GrandPrixData = {
        meeting,
        sessions: sessionsData as any,
        metadata: {
          scraped_at: new Date().toISOString(),
          season: meeting.year,
          round: this.calculateRound(meeting),
        },
      };

      console.log('\n‚îÅ'.repeat(50));
      console.log('‚úÖ Scraping completato con successo!\n');

      return {
        success: true,
        data: grandPrixData,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      console.error('‚ùå Errore durante lo scraping:', error);
      return this.createErrorResult('SCRAPER_ERROR', error);
    }
  }

  /**
   * Recupera i dati di un Gran Premio specifico
   */
  async scrapeGrandPrix(
    meetingKey: number,
    config: Omit<ScraperConfig, 'meetingKey'> = {}
  ): Promise<ScraperResult<GrandPrixData>> {
    try {
      console.log('\nüèéÔ∏è  F1 DATA SCRAPER - Gran Premio Specifico\n');
      console.log('‚îÅ'.repeat(50));

      // 1. Ottieni meeting
      const meeting = await this.getMeetingByKey(meetingKey, config.year);
      if (!meeting) {
        return {
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: `Meeting ${meetingKey} non trovato`,
          },
          timestamp: new Date().toISOString(),
        };
      }

      console.log(`\nüìç ${meeting.meeting_name}`);
      console.log(`   ${meeting.location}, ${meeting.country_name}`);

      // 2. Recupera sessioni
      const sessionsResult = await this.service.getSessions(meeting.meeting_key);
      if (!sessionsResult.success || !sessionsResult.data) {
        return {
          success: false,
          error: sessionsResult.error ?? { code: 'NO_DATA', message: 'Nessuna sessione disponibile' },
          timestamp: new Date().toISOString(),
        };
      }

      const sessions = sessionsResult.data;
      const sessionsToScrape = config.sessionTypes
        ? sessions.filter(s => config.sessionTypes!.includes(s.session_name as any))
        : sessions;

      // 3. Recupera dati sessioni
      const sessionsData = await this.scrapeSessionsData(sessionsToScrape, config);

      // 4. Costruisci risultato
      const grandPrixData: GrandPrixData = {
        meeting,
        sessions: sessionsData as any,
        metadata: {
          scraped_at: new Date().toISOString(),
          season: meeting.year,
          round: this.calculateRound(meeting),
        },
      };

      console.log('\n‚îÅ'.repeat(50));
      console.log('‚úÖ Scraping completato!\n');

      return {
        success: true,
        data: grandPrixData,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      return this.createErrorResult('SCRAPER_ERROR', error);
    }
  }

  /**
   * Recupera tutti i Gran Premi di una stagione
   */
  async scrapeSeason(
    year: number,
    config: Omit<ScraperConfig, 'year'> = {}
  ): Promise<ScraperResult<GrandPrixData[]>> {
    try {
      console.log(`\nüèéÔ∏è  F1 DATA SCRAPER - Stagione ${year}\n`);
      console.log('‚îÅ'.repeat(50));

      const meetingsResult = await this.service.getMeetings(year);
      if (!meetingsResult.success || !meetingsResult.data) {
        return {
          success: false,
          error: meetingsResult.error ?? { code: 'NO_DATA', message: 'Nessun meeting disponibile' },
          timestamp: new Date().toISOString(),
        };
      }

      const meetings = meetingsResult.data;
      console.log(`\nüìÖ Trovati ${meetings.length} Gran Premi\n`);

      const allGrandsPrix: GrandPrixData[] = [];

      for (const meeting of meetings) {
        const gpResult = await this.scrapeGrandPrix(meeting.meeting_key, config);
        
        if (gpResult.success && gpResult.data) {
          allGrandsPrix.push(gpResult.data);
        }
      }

      console.log('\n‚îÅ'.repeat(50));
      console.log(`‚úÖ Completato scraping di ${allGrandsPrix.length} Gran Premi!\n`);

      return {
        success: true,
        data: allGrandsPrix,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      return this.createErrorResult('SCRAPER_ERROR', error);
    }
  }

  /**
   * Recupera dati per un array di sessioni
   */
  private async scrapeSessionsData(
    sessions: Session[],
    config: Omit<ScraperConfig, 'year' | 'meetingKey'>
  ): Promise<Record<string, SessionData>> {
    const sessionsData: Record<string, SessionData> = {};

    for (const session of sessions) {
      const sessionDataResult = await this.service.getCompleteSessionData(session, {
        includeLaps: config.includeLaps ?? false,
        includeStints: config.includeStints ?? false,
        includePits: config.includePits ?? false,
        includeRaceControl: config.includeRaceControl ?? false,
        includeStartingGrid: session.session_type === 'Race',
      });

      if (sessionDataResult.success && sessionDataResult.data) {
        const key = this.normalizeSessionName(session.session_name);
        sessionsData[key] = sessionDataResult.data;
      }
    }

    return sessionsData;
  }

  /**
   * Recupera un meeting specifico per chiave
   */
  private async getMeetingByKey(
    meetingKey: number,
    year?: number
  ): Promise<Meeting | null> {
    const meetingsResult = await this.service.getMeetings(
      year ?? new Date().getFullYear()
    );

    if (!meetingsResult.success || !meetingsResult.data) {
      return null;
    }

    return meetingsResult.data.find(m => m.meeting_key === meetingKey) ?? null;
  }

  /**
   * Normalizza nome sessione per chiavi object
   */
  private normalizeSessionName(sessionName: string): string {
    return sessionName
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/[^a-z0-9]/g, '');
  }

  /**
   * Calcola il round number del meeting
   */
  private calculateRound(meeting: Meeting): number {
    // Il round √® dedotto dalla chiave del meeting
    // OpenF1 non fornisce direttamente il round number
    return meeting.meeting_key % 100;
  }

  /**
   * Crea un risultato di errore standardizzato
   */
  private createErrorResult(code: string, error: unknown): ScraperResult<never> {
    return {
      success: false,
      error: {
        code,
        message: error instanceof Error ? error.message : 'Errore sconosciuto',
      },
      timestamp: new Date().toISOString(),
    };
  }
}
